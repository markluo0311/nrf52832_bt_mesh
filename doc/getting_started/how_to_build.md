# Building the mesh stack

The mesh library and example applications can be built using either @link_cmake <!--CMake: https://cmake.org/--> or
@link_seggerstudio<!--SEGGER Embedded Studio: https://www.segger.com/products/development-tools/embedded-studio/?L=0-->.

Using CMake provides the possiblity to build both for host (unit tests) and target, while SEGGER
Embedded Studio provides a way of quickly getting the example code up and running with full debug
capability.

Before you continue, check @ref md_doc_getting_started_how_to_toolchain ro instructions on setting up the
development environment for mesh.

## Building with SEGGER Embedded Studio

To build with SEGGER Embedded Studio, open the project file located in `examples/examples.emProject`.

To compile the examples, choose the target for which you want to compile: Go to
`Build -> Set Active Build Configuration` and select the desired target configuration.

To compile all projects, go to `Build -> Rebuild Solution`.

To program a specific example to a device,
first right-click on the project that you wish to program and choose `Set as Active Project` (if not already
active). Then connect to the target device using `Target -> Connect J-Link`. The target can then be
programmed using `Target -> Download <example_name>.hex`. This procedure will program both the application and the SoftDevice
in one go.

## Building with CMake
From @link_about_cmake: <!-- https://cmake.org/overview/ -->

> CMake is an extensible, open-source system that manages the build process in an operating system and
> in a compiler-independent manner.

In other words, CMake does not build from the source directly, but generates the native build tool
files (for example, a set of Makefiles or a `build.ninja` configuration).

> **Important**: All examples built by the CMake-generated build system do not include the SoftDevice
> as part of the generated HEX files. Therefore, the SoftDevice must already be present on the device before
> flashing the HEX file for the example mesh application.

### Building on Windows with Ninja
Good practice is to create a build folder in the root directory for the mesh stack repository, where all
artifacts generated by the Ninja build system are stored, such as:

    mesh-btle $ mkdir build      # Create a build directory
    mesh-btle $ cd build         # Move into that directory

Before you can build with Ninja, you must generate the correct build files with CMake:

    cmake -G Ninja -DBUILD_TOOLCHAIN=GCC -DTARGET_PLATFORM=52 ..    # Build with arm-none-eabi-gcc for nRF52

After the Ninja build files are generated,
running `ninja` will build all the targets (examples and libraries) except for documentation and pc-lint.
To see a list of available build targets, run the following command:

    ninja -t targets

To build a specific target from this list, run, for example, `ninja 51_MBTLE_CORE`.

CMake generates Ninja build files in the folder in which CMake is run (but not in any of its subfolders),
so all targets must be built from that directory. In other words, in-directory building is not supported
and running `ninja` in one of the example folders will result in an error message generated by the Ninja build system.

However, the mesh stack can be built from its root directory as well, which will place the generated
artifacts in the folder where the source files are kept:

    mesh-btle $ cmake -G Ninja    # Generate build files
    mesh-btle $ ninja


By default, CMake is configured to build for target using the armcc v5 compiler. To build
with arm-none-eabi-gcc instead, set `BUILD_TOOLCHAIN` to `GCC`, such as:

    mesh-btle $ mkdir build && cd build             # Create a build directory
    build $ cmake -G Ninja -DBUILD_TOOLCHAIN=GCC .. # Generate build files
    build $ ninja



### Building on Linux with make
CMake can generate `make` files as well, which is natively supported by Linux. This is the preferred
method of building C-based programs. On Linux, the build system will default to GCC and make.

To build on Linux with GCC, run the following commands:

    mesh-btle $ mkdir build && cd build       # Create a build directory
    build $ cmake ..                          # Generate build files
    build $ make


To build on Linux with armcc v5:

    mesh-btle $ mkdir build && cd build       # Create a build directory
    build $ cmake -DBUILD_TOOLCHAIN=ARM ..    # Generate build files
    build $ make


### Useful CMake command line options
CMake allows you to generate project files in release or debug configurations. To do so,
use the `-DCMAKE_BUILD_TYPE` option:

    build $ cmake -DCMAKE_BUILD_TYPE=Release .. # Generates build files in release mode
    build $ cmake -DCMAKE_BUILD_TYPE=Debug ..   # Generates build files in debug mode


To set which hardware platform to target, use the `-DTARGET_PLATFORM` option:

    build $ cmake -DTARGET_PLATFORM=51 .. # Generates build files for nRF51
    build $ cmake -DTARGET_PLATFORM=52 .. # Generates build files for nRF52


The default hardware platform used when no target platform has been specified is nRF51.

### Building the documentation

To build all documentation (API documentation and internal documentation), call the build system with the target `doc`. On Windows, run `ninja doc`. On Linux, run `make doc`.

The Doxygen documentation is generated in `<build folder>/doc/html`.


### Unit test build (host)

The nRF5 SDK for Bluetooth Mesh contains a set of unit tests that verify module behavior. These unit tests run on the
host system (i.e. PC, not the nRF5 device), and are built with GCC. See @ref md_doc_getting_started_how_to_toolchain for
toolchain requirements.

The nRF5 SDK for Bluetooth Mesh depends on two frameworks for unit testing:
* @link_unity <!--Unity: https://github.com/ThrowTheSwitch/Unity--> is the unit testing
  framework that is used for running the tests.
* @link_cmock <!--CMock: https://github.com/ThrowTheSwitch/CMock--> is used by the unit
  tests to generate mocks.

CMock bundles Unity as a submodule, thus in the same directory as the nRF5 SDK for Bluetooth Mesh, make sure
to clone the CMock repository recursively:

    $ git clone https://github.com/ThrowTheSwitch/CMock.git --recursive cmock

The directory structure should now look like this:

    .
    +-- cmock/
    +-- nrf5_sdk_for_bluetooth_mesh/

Enter the `nrf5_sdk_for_bluetooth_mesh` directory, and make a new build directory, e.g. `build_host`:

    nrf5_sdk_for_bluetooth_mesh $ mkdir -p build_host && cd build_host

To build for host, so that the unit tests can be run, set the option `BUILD_HOST`
to `ON` and provide the path to CMock:

    build_host $ cmake -G Ninja -DBUILD_HOST=ON -DCMOCK_ROOT=<dir/cmock> ..

If a different version of Unity from the one included as a submodule in CMock is wanted, this can be specified by
passing `-DUNITY_ROOT=<dir/unity>` to CMake. Note that the two paths can be set permanently with environmental variables
(`UNITY_ROOT` and `CMOCK_ROOT`), and CMake is set up to look for CMock in the directory above the
`nrf5_sdk_for_bluetooth_mesh`, so if the instructions above have been followed, both these variables are redundant.

Build all the unit tests with ninja:

    build_host $ ninja

To run the tests, run `ctest` (bundled with CMake) or call `ninja test` in the build directory.

    build_host $ ctest # Run all unit tests
